/**
 * Calendar Integration Service
 * Handles calendar integration for accepted quotes
 */

import { supabase } from './supabase';
import { QuoteService, QuoteData } from './quoteService';

export interface CalendarEvent {
  id: string;
  quoteId: string;
  title: string;
  description: string;
  startDate: string;
  startTime: string;
  endDate?: string;
  endTime?: string;
  location: string;
  notes: string[];
}

export class CalendarService {
  // Generate job notes from quote data
  static generateJobNotes(quote: QuoteData): Array<{ type: string; note: string; autoGenerated: boolean }> {
    const notes: Array<{ type: string; note: string; autoGenerated: boolean }> = [];

    // Check for boxes needed
    const boxesNeeded = quote.upsells?.some((u: any) => 
      u.id?.includes('box') || u.name?.toLowerCase().includes('box')
    );
    if (boxesNeeded) {
      notes.push({
        type: 'equipment',
        note: 'Bring moving boxes',
        autoGenerated: true
      });
    }

    // Check for special items
    const specialItems = quote.upsells?.filter((u: any) => 
      u.id?.includes('piano') || 
      u.id?.includes('pool') || 
      u.id?.includes('safe') ||
      u.id?.includes('gym') ||
      u.id?.includes('specialty')
    );
    if (specialItems && specialItems.length > 0) {
      notes.push({
        type: 'special_handling',
        note: `Special handling required: ${specialItems.map((u: any) => u.name).join(', ')}`,
        autoGenerated: true
      });
    }

    // Check for multiple trucks
    const totalCubicFeet = quote.detections?.reduce((sum: number, d: any) => {
      const cf = d.cubicFeet || 0;
      return sum + (cf * (d.qty || 1));
    }, 0) || 0;
    const TRUCK_CAPACITY = 1700;
    if (totalCubicFeet > TRUCK_CAPACITY) {
      const trucksNeeded = Math.ceil(totalCubicFeet / TRUCK_CAPACITY);
      notes.push({
        type: 'equipment',
        note: `Multiple trucks required: ${trucksNeeded} truck(s)`,
        autoGenerated: true
      });
    }

    // Check for TV disassembly
    const tvDisassembly = quote.upsells?.some((u: any) => 
      u.id?.includes('tv-disassembly')
    );
    if (tvDisassembly) {
      notes.push({
        type: 'special_handling',
        note: 'TV disassembly and assembly required',
        autoGenerated: true
      });
    }

    // Check for packing/unpacking
    const packing = quote.upsells?.some((u: any) => 
      u.id === 'packing'
    );
    if (packing) {
      notes.push({
        type: 'service',
        note: 'Packing service included',
        autoGenerated: true
      });
    }

    const unpacking = quote.upsells?.some((u: any) => 
      u.id === 'unpacking'
    );
    if (unpacking) {
      notes.push({
        type: 'service',
        note: 'Unpacking service included',
        autoGenerated: true
      });
    }

    // Multi-day moves (if volume is very large)
    if (totalCubicFeet > TRUCK_CAPACITY * 2) {
      notes.push({
        type: 'scheduling',
        note: 'May require multiple days - coordinate with customer',
        autoGenerated: true
      });
    }

    return notes;
  }

  // Create calendar event from accepted quote
  static async createCalendarEvent(quote: QuoteData): Promise<CalendarEvent> {
    if (!quote.id) throw new Error('Quote must have an ID');
    
    const jobNotes = this.generateJobNotes(quote);
    const moveTime = quote.moveTimeConfirmed || '09:00'; // Default 9 AM
    const [hours, minutes] = moveTime.split(':');
    
    // Estimate end time based on quote hours
    const quoteHours = quote.estimate?.hours || 4;
    const startDateTime = new Date(`${quote.moveDate}T${moveTime}`);
    const endDateTime = new Date(startDateTime);
    endDateTime.setHours(endDateTime.getHours() + Math.ceil(quoteHours));

    const event: CalendarEvent = {
      id: `quote-${quote.id}`,
      quoteId: quote.id,
      title: `Move: ${quote.customerName}`,
      description: `Moving from ${quote.originAddress} to ${quote.destinationAddress}`,
      startDate: quote.moveDate,
      startTime: moveTime,
      endDate: endDateTime.toISOString().split('T')[0],
      endTime: `${endDateTime.getHours().toString().padStart(2, '0')}:${endDateTime.getMinutes().toString().padStart(2, '0')}`,
      location: `${quote.originAddress} → ${quote.destinationAddress}`,
      notes: jobNotes.map(n => n.note)
    };

    // Update quote with calendar event ID and job notes
    await supabase
      .from('quotes')
      .update({
        calendar_event_id: event.id,
        calendar_synced: true,
        job_notes: jobNotes
      })
      .eq('id', quote.id);

    // In production, this would sync with Google Calendar, Outlook, etc.
    // For now, we'll just store it in the database
    console.log('Calendar event created:', event);
    
    return event;
  }

  // Get calendar events for a date range
  static async getCalendarEvents(startDate: string, endDate: string): Promise<CalendarEvent[]> {
    const { data: quotes, error } = await supabase
      .from('quotes')
      .select('*')
      .eq('status', 'accepted')
      .eq('calendar_synced', true)
      .gte('move_date', startDate)
      .lte('move_date', endDate)
      .order('move_date', { ascending: true });

    if (error) throw error;

    return quotes.map(quote => {
      // Map quote data manually since mapQuoteData is private
      const quoteData: QuoteData = {
        id: quote.id,
        customerName: quote.customer_name,
        customerEmail: quote.customer_email,
        customerPhone: quote.customer_phone,
        moveDate: quote.move_date,
        originAddress: quote.origin_address,
        destinationAddress: quote.destination_address,
        detections: quote.detections,
        estimate: quote.estimate,
        upsells: quote.upsells,
        totalAmount: parseFloat(quote.total_amount),
        photos: quote.photos,
        status: quote.status,
        questions: quote.questions,
        moveTimeConfirmed: quote.move_time_confirmed,
        jobNotes: quote.job_notes
      };
      
      return {
        id: quote.calendar_event_id || `quote-${quote.id}`,
        quoteId: quote.id,
        title: `Move: ${quoteData.customerName}`,
        description: `Moving from ${quoteData.originAddress} to ${quoteData.destinationAddress}`,
        startDate: quoteData.moveDate,
        startTime: quoteData.moveTimeConfirmed || '09:00',
        location: `${quoteData.originAddress} → ${quoteData.destinationAddress}`,
        notes: quoteData.jobNotes?.map((n: any) => n.note) || []
      };
    });
  }

  // Export to Google Calendar format (ICS)
  static exportToICS(events: CalendarEvent[]): string {
    let ics = 'BEGIN:VCALENDAR\nVERSION:2.0\nPRODID:-//MovSense//EN\n';
    
    events.forEach(event => {
      const start = `${event.startDate.replace(/-/g, '')}T${event.startTime.replace(':', '')}00`;
      const end = event.endDate && event.endTime 
        ? `${event.endDate.replace(/-/g, '')}T${event.endTime.replace(':', '')}00`
        : start;
      
      ics += `BEGIN:VEVENT\n`;
      ics += `DTSTART:${start}\n`;
      ics += `DTEND:${end}\n`;
      ics += `SUMMARY:${event.title}\n`;
      ics += `DESCRIPTION:${event.description}\n`;
      ics += `LOCATION:${event.location}\n`;
      if (event.notes.length > 0) {
        ics += `NOTE:${event.notes.join('; ')}\n`;
      }
      ics += `END:VEVENT\n`;
    });
    
    ics += 'END:VCALENDAR';
    return ics;
  }
}

