/**
 * Quote Service for managing quotes in Supabase
 */

import { supabase } from './supabase';
import { CalendarService } from './calendarService';
import { FollowUpService } from './followUpService';

export interface QuoteData {
  id?: string;
  customerName: string;
  customerEmail: string;
  customerPhone: string;
  moveDate: string;
  originAddress: string;
  destinationAddress: string;
  detections: any[];
  estimate: any;
  upsells: any[];
  totalAmount: number;
  photos?: any[];
  status?: 'pending' | 'accepted' | 'declined';
  questions?: string[];
  createdAt?: string;
  // CRM fields
  leadSource?: string;
  declineReason?: string;
  moveTimeConfirmed?: string;
  priceOverride?: boolean;
  originalTotalAmount?: number;
  overrideReason?: string;
  followUpDate?: string;
  customLogoUrl?: string;
  brandColors?: { primary?: string; secondary?: string; accent?: string };
  emailTracking?: {
    opens: Array<{ timestamp: string; ip?: string }>;
    lastOpened?: string;
    firstOpened?: string;
  };
  acceptedAt?: string;
  declinedAt?: string;
  acceptedBy?: 'customer' | 'sales_rep';
  declinedBy?: 'customer' | 'sales_rep';
  salesRepNotes?: string;
  calendarEventId?: string;
  calendarSynced?: boolean;
  paymentStatus?: 'pending' | 'invoice_sent' | 'paid' | 'overdue';
  stripeInvoiceId?: string;
  invoiceSentAt?: string;
  paymentDueDate?: string;
  jobNotes?: Array<{ type: string; note: string; autoGenerated: boolean }>;
  customerAgreementAccepted?: boolean;
  customerAgreementAcceptedAt?: string;
}

export class QuoteService {
  static async createQuote(quoteData: QuoteData): Promise<QuoteData> {
    // Get the current authenticated user
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    
    if (authError) {
      console.error('Auth error:', authError);
      throw new Error(`Authentication error: ${authError.message || 'Please log in again.'}`);
    }
    
    if (!user) {
      throw new Error('User must be authenticated to create quotes. Please log in.');
    }
    
    console.log('Creating quote for user:', user.id);

    // Calculate follow-up date (default: next day)
    const followUpDate = quoteData.followUpDate || this.getDefaultFollowUpDate();
    
    const insertData: any = {
      user_id: user.id, // Required for RLS policy
        customer_name: quoteData.customerName,
        customer_email: quoteData.customerEmail,
        customer_phone: quoteData.customerPhone,
        move_date: quoteData.moveDate,
        origin_address: quoteData.originAddress,
        destination_address: quoteData.destinationAddress,
        detections: quoteData.detections,
        estimate: quoteData.estimate,
        upsells: quoteData.upsells,
        total_amount: quoteData.totalAmount,
        photos: quoteData.photos || [],
        status: quoteData.status || 'pending',
      questions: quoteData.questions || [],
      lead_source: quoteData.leadSource || null,
      move_time_confirmed: quoteData.moveTimeConfirmed || null,
      price_override: quoteData.priceOverride || false,
      original_total_amount: quoteData.originalTotalAmount || quoteData.totalAmount,
      override_reason: quoteData.overrideReason || null,
      follow_up_date: followUpDate,
      custom_logo_url: quoteData.customLogoUrl || null,
      brand_colors: quoteData.brandColors || {},
      email_tracking: quoteData.emailTracking || { opens: [], last_opened: null, first_opened: null },
      sales_rep_notes: quoteData.salesRepNotes || null,
      job_notes: quoteData.jobNotes || [],
      payment_status: quoteData.paymentStatus || 'pending'
    };

    const { data, error } = await supabase
      .from('quotes')
      .insert(insertData)
      .select()
      .single();

    if (error) {
      console.error('Supabase insert error:', error);
      console.error('Insert data (excluding sensitive fields):', {
        ...insertData,
        detections: `[${insertData.detections?.length || 0} items]`,
        estimate: '[estimate data]',
        upsells: `[${insertData.upsells?.length || 0} items]`
      });
      throw error;
    }

    const savedQuote = this.mapQuoteData(data);
    
    // Create follow-up reminder after quote is created
    if (savedQuote.id) {
      try {
        await FollowUpService.createFollowUp(
          savedQuote.id,
          followUpDate,
          'automatic'
        );
      } catch (error) {
        console.error('Error creating follow-up:', error);
        // Don't fail quote creation if follow-up fails
      }
    }

    return savedQuote;
  }

  private static getDefaultFollowUpDate(): string {
    const tomorrow = new Date();
    tomorrow.setDate(tomorrow.getDate() + 1);
    return tomorrow.toISOString().split('T')[0];
  }

  private static mapQuoteData(data: any): QuoteData {
    return {
      id: data.id,
      customerName: data.customer_name,
      customerEmail: data.customer_email,
      customerPhone: data.customer_phone,
      moveDate: data.move_date,
      originAddress: data.origin_address,
      destinationAddress: data.destination_address,
      detections: data.detections,
      estimate: data.estimate,
      upsells: data.upsells,
      totalAmount: parseFloat(data.total_amount),
      photos: data.photos,
      status: data.status,
      questions: data.questions,
      createdAt: data.created_at,
      leadSource: data.lead_source,
      declineReason: data.decline_reason,
      moveTimeConfirmed: data.move_time_confirmed,
      priceOverride: data.price_override,
      originalTotalAmount: data.original_total_amount ? parseFloat(data.original_total_amount) : undefined,
      overrideReason: data.override_reason,
      followUpDate: data.follow_up_date,
      customLogoUrl: data.custom_logo_url,
      brandColors: data.brand_colors,
      emailTracking: data.email_tracking,
      acceptedAt: data.accepted_at,
      declinedAt: data.declined_at,
      acceptedBy: data.accepted_by,
      declinedBy: data.declined_by,
      salesRepNotes: data.sales_rep_notes,
      calendarEventId: data.calendar_event_id,
      calendarSynced: data.calendar_synced,
      paymentStatus: data.payment_status,
      stripeInvoiceId: data.stripe_invoice_id,
      invoiceSentAt: data.invoice_sent_at,
      paymentDueDate: data.payment_due_date,
      jobNotes: data.job_notes,
      customerAgreementAccepted: data.customer_agreement_accepted,
      customerAgreementAcceptedAt: data.customer_agreement_accepted_at
    };
  }

  static async getQuote(quoteId: string): Promise<QuoteData | null> {
    const { data, error } = await supabase
      .from('quotes')
      .select('*')
      .eq('id', quoteId)
      .single();

    if (error) {
      if (error.code === 'PGRST116') return null; // Not found
      throw error;
    }

    return this.mapQuoteData(data);
  }

  static async updateQuoteStatus(
    quoteId: string, 
    status: 'pending' | 'accepted' | 'declined',
    actionBy?: 'customer' | 'sales_rep',
    declineReason?: string
  ): Promise<void> {
    const updateData: any = { 
      status,
      updated_at: new Date().toISOString()
    };

    if (status === 'accepted') {
      updateData.accepted_at = new Date().toISOString();
      updateData.accepted_by = actionBy || 'customer';
      
      // Auto-create calendar event for accepted quotes
      try {
        const quote = await this.getQuote(quoteId);
        if (quote) {
          await CalendarService.createCalendarEvent(quote);
        }
      } catch (error) {
        console.error('Error creating calendar event:', error);
        // Don't fail the quote acceptance if calendar fails
      }
    } else if (status === 'declined') {
      updateData.declined_at = new Date().toISOString();
      updateData.declined_by = actionBy || 'customer';
      if (declineReason) {
        updateData.decline_reason = declineReason;
      }
    }

    const { error } = await supabase
      .from('quotes')
      .update(updateData)
      .eq('id', quoteId);

    if (error) throw error;

    // Track in email events
    await supabase
      .from('quote_email_events')
      .insert({
        quote_id: quoteId,
        event_type: status === 'accepted' ? 'accepted' : 'declined',
        event_data: { 
          timestamp: new Date().toISOString(),
          actionBy: actionBy || 'customer',
          declineReason: declineReason || null
        }
      });
  }

  static async getUserQuotes(): Promise<QuoteData[]> {
    const { data, error } = await supabase
      .from('quotes')
      .select('*')
      .order('created_at', { ascending: false });

    if (error) throw error;

    return data.map(quote => this.mapQuoteData(quote));
  }

  // Track email open event
  static async trackEmailOpen(quoteId: string, ipAddress?: string, userAgent?: string): Promise<void> {
    // Record in email_tracking JSONB field
    const { data: quote } = await supabase
      .from('quotes')
      .select('email_tracking')
      .eq('id', quoteId)
      .single();

    if (!quote) return;

    const tracking = quote.email_tracking || { opens: [], last_opened: null, first_opened: null };
    const now = new Date().toISOString();
    
    tracking.opens.push({ timestamp: now, ip: ipAddress });
    tracking.last_opened = now;
    if (!tracking.first_opened) {
      tracking.first_opened = now;
    }

    await supabase
      .from('quotes')
      .update({ email_tracking: tracking })
      .eq('id', quoteId);

    // Also insert into detailed tracking table
    await supabase
      .from('quote_email_events')
      .insert({
        quote_id: quoteId,
        event_type: 'opened',
        ip_address: ipAddress,
        user_agent: userAgent,
        event_data: { timestamp: now }
      });
  }

  // Update quote with override price
  static async updateQuotePrice(
    quoteId: string, 
    newTotal: number, 
    overrideReason: string
  ): Promise<void> {
    const { data: quote } = await supabase
      .from('quotes')
      .select('total_amount')
      .eq('id', quoteId)
      .single();

    if (!quote) throw new Error('Quote not found');

    const { error } = await supabase
      .from('quotes')
      .update({
        total_amount: newTotal,
        price_override: true,
        original_total_amount: quote.total_amount,
        override_reason: overrideReason,
        updated_at: new Date().toISOString()
      })
      .eq('id', quoteId);

    if (error) throw error;
  }

  // Add question to quote
  static async addQuestion(quoteId: string, question: string): Promise<void> {
    const { data: quote } = await supabase
      .from('quotes')
      .select('questions')
      .eq('id', quoteId)
      .single();

    if (!quote) throw new Error('Quote not found');

    const questions = quote.questions || [];
    questions.push(question);

    const { error } = await supabase
      .from('quotes')
      .update({ questions, updated_at: new Date().toISOString() })
      .eq('id', quoteId);

    if (error) throw error;

    // Track in email events
    await supabase
      .from('quote_email_events')
      .insert({
        quote_id: quoteId,
        event_type: 'question_submitted',
        event_data: { question, timestamp: new Date().toISOString() }
      });
  }

  // Get analytics data
  static async getAnalytics(): Promise<{
    totalQuotes: number;
    pendingQuotes: number;
    acceptedQuotes: number;
    declinedQuotes: number;
    totalRevenue: number;
    averageQuoteValue: number;
    conversionRate: number;
    quotesByPriceRange: Array<{ range: string; count: number }>;
  }> {
    const { data: quotes, error } = await supabase
      .from('quotes')
      .select('status, total_amount, created_at');

    if (error) throw error;

    const totalQuotes = quotes.length;
    const pendingQuotes = quotes.filter(q => q.status === 'pending').length;
    const acceptedQuotes = quotes.filter(q => q.status === 'accepted').length;
    const declinedQuotes = quotes.filter(q => q.status === 'declined').length;
    const totalRevenue = quotes
      .filter(q => q.status === 'accepted')
      .reduce((sum, q) => sum + parseFloat(q.total_amount || 0), 0);
    const averageQuoteValue = totalQuotes > 0 
      ? quotes.reduce((sum, q) => sum + parseFloat(q.total_amount || 0), 0) / totalQuotes 
      : 0;
    const conversionRate = totalQuotes > 0 ? (acceptedQuotes / totalQuotes) * 100 : 0;

    // Price ranges
    const ranges = [
      { min: 0, max: 500, label: '$0-$500' },
      { min: 500, max: 1000, label: '$500-$1,000' },
      { min: 1000, max: 2000, label: '$1,000-$2,000' },
      { min: 2000, max: 5000, label: '$2,000-$5,000' },
      { min: 5000, max: Infinity, label: '$5,000+' }
    ];

    const quotesByPriceRange = ranges.map(range => ({
      range: range.label,
      count: quotes.filter(q => {
        const amount = parseFloat(q.total_amount || 0);
        return amount >= range.min && amount < range.max;
      }).length
    }));

    return {
      totalQuotes,
      pendingQuotes,
      acceptedQuotes,
      declinedQuotes,
      totalRevenue,
      averageQuoteValue,
      conversionRate,
      quotesByPriceRange
    };
  }
}





